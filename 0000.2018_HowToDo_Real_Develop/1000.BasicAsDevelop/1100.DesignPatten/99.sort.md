
# 정렬
: 2개 이상의 자료를 순서대로 재배치하는 것.


## 삽입 정렬
## 셀 정렬
## 병합 정렬
## 기수 정렬
## 힙정렬
## 트리정렬


## 선택정렬
: 전체 원소들 중에서 기준 위치에 맞는 원소를 선택하여 자리를 교환하는 방식으로 정렬

### 선택 정렬 방법
1. 전체 원소중 가장 작은 원소를 찾아서 첫번째 원소와 자리를 교환한다.
2. 두번째 작은 원소를 찾아 두번째 자리를 교환한다.
3. 반복한다.

### 복잡도
어떤 경우에서나 비교횟수가 같으므로 시간 복잡도는 O(n2)

```java
public class Selection {
    public void sort(int[] data){
        int size = data.length;
        int min; 
        int temp;
        
        for(int i=0; i<size-1; i++){ // size-1 : 마지막 요소는 자연스럽게 정렬됨
            min = i;
            for(int j=i+1; j<size; j++){
                if(data[min] > data[j]){
                    min = j;
                }
            }
            temp = data[min];
            data[min] = data[i];
            data[i] = temp;
        }
    }
}
```

## 버블 정렬
: 인접한 두개의 원소를 비교해서 자리를 교환하는 방식

### 버블 정렬 방법
1. 첫번째 원소부터 마지막 원소까지 반옥하여 한단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬

### 버블 정렬 복잡도
어떤 경우에서나 비교횟수가 같으므로 시간 복잡도는 O(n2)
```java

    public static int[] BubbleSort(int [] items) {
        for(int i=0;i<items.length-1;i++) {
            for(int j=0; j<items.length-1; j++) {
                if (items[j] > items[j+1]) { //원소를 비교하여 앞 원소가 크다면..
                    int temp = items[j]; //앞 원소를 임시 저
                    items[j] = items[j+1]; //앞 원소의 자리에 다음 원소 값 저장
                    items[j+1] = temp; //다음 원소의 자리에 임시로 저장했던 원소값 저
                }
            }
        }
        return items;
    }

```

## 퀵 정렬
: 정렬한 전체 원소에 대해 정렬을 수행하지 않고, 기준값을 중심으로 왼쪽부분집합과 오른쪽 부분집합으로 분할하여 정렬하는 방법

### 퀵정렬 방법
1. 분할 : 정렬할 자료들을 기준값을 중심으로 2개의 부분 집합으로 분할하기
2. 정복 : 부분 집합의 원소들 중에서 기준값보다 작은 원소들은 왼쪽 부분집합으로, 기준값보다 큰 원소들은 오른쪽 부분집합으로 정령하기

```java
    public void quickSort(int[] data, int l, int r){
        int left = l;
        int right = r;
        int pivot = data[(l+r)/2];
        
        do{
            while(data[left] < pivot) left++;
            while(data[right] > pivot) right--;
            if(left <= right){    
                int temp = data[left];
                data[left] = data[right];
                data[right] = temp;
                left++;
                right--;
            }
        }while (left <= right);
        
        if(l < right) sort(data, l, right);
        if(r > left) sort(data, left, r);
    }
    

```

### 퀵 정렬 복잡도
 시간 복잡도는 O(nlog2n)

