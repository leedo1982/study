
09장 예외
- 프로그램의 가독성 안정성 유지보수성을 향상 시킬 수 있으나 반대효과도 낸다.
효과적인 활용을 위한 지침

------------------------------------------------------------------------

규칙 57. 예외는 예외적인 상황에만 사용하라(평상시 제어흐름에 사용하지 마라)

예외를 통한 순횐문은 표준적 순환문보다 훨~씬 느릴 뿐 아니라 올바른 동작을보장할 수 없다.


상태종속적 메소드를 가진 클래스에는 보통 해당 매서드를 호출해도 되는지를 알기 위한
상태검사 메서드가 별도로 존재한다(ex. Iterator -> hasNext())

잘설계된 API는 클라이언트에게 평상시 제어흐름의 일부로 예외를 사용하도록 강요해서는 안된다




------------------------------------------------------------------------

규칙 58. 복구가능 상태에는 점검지정 예외를 사용하고, 프로그래밍 오류에는 실행시점 예외를 이용하라
 
java는 세가지 종류의 throwable를 제공한다
1. 점검지정예외(checkedexception)
2. 실행시점 예외(runtiome exception)
3. 오류(error)

딱 떨어지는 기준은 아니나, 훌륭한 지침으로 삼을 만한 일반 규칙이 있어 소개한다

점검지정 예외를 사용할 것인지 무점검 예외(unchecked exception)를 사용할 것인지에 대한 기본적인 규칙은,
호출자(caller) 측에서 복구할 것으로 여겨지는 상황에 대해서는 점검지정 예외를 이용해야 한다

API 사용자에게 점검지정 예외를 준다는 것은 그상태를 복구할 권한을 준다는 뜻이다

무점검 (unchecked) 'throwable'에는 실행시점 예외와 오류 두가지가 있으며, 동작 방식은 같다
둘다 catch 처리할 필요가 없으며 일반적으로는 처리해서도 안된다

프로그래밍 오류를 표현할 때는 실행시점 예외를 사용하라

대부분의 실행시점 예외는 선행조건 위반(precondition violation)을 나타낸다.

자바 언어 명세에 강제된 사항은 아니지만, 오류(error)는  JVM이 자원부족등이나 불변식 위반 등으로
더이상 프로그램을 실행할 수 없는 상태에 도달했음을 알리기 위해 사용한다
이관습은 거의 보편적으로 받아들여지고 있어서, Error 의 하위 클래스는 새로 만들지 않는 것이 최선이다
따라서, 사용자 정의 무점검 throwable은 RuntimeException의 하위 클래스로 만들어야 한다.

API를 설계하다 보면 예외도 임의 메서드를 가질 수 있는 완전한 객체라는 사실을 가끔 잊는다
그런 메소드의 주된 용도는, 예외를 발생시킨 상태에 대한 정보를 예외를 받아(catch) 처리할 코드에 전달하는 것이다


------------------------------------------------------------------------

규칙59. 불필요한 점검지정 예외의 사용은 피해라

점검지정 예외는 자바가 제공하는 멋진 기능 가운데하나다
코드를 반환하는 것과는 달리, 프로그래머로하여금 예외적인 상황을 처리하도록 강제함으로써 안정감을 높인다
단, 너무 남발하면 사용하기 불편한 API가 될수도 있다

점검지정 예외를 무점검 예외로 바꾸는 한가지 방법은, 예외를 던지는 메서드를 둘로 나눠서 첫번째 메서드가 boolean 값을
반환하도록 만드는 것이다

```
//before

// 예외를 점검하도록 지정된 메서드 호출
try{
    obj.action(args);
}catch(TheCheckedException e){
    // 예외적 상황 처리
    .............ㅏ
}


//after

// 상태 점검 메서드를 거쳐서 무점검 예외 메서드 호출
if(obj.actionPermitted(args)){
    obj.action(args);
}else{
    // 예외적 상황 처리
    .............ㅏ
}
```
항상 이렇게 리팩터링 할수 있는 것은 아니나 
이전 방식에 비해 더깔끔하다고 말하기는 어려우나 더 유연한 API가 되었음은 사실이다

------------------------------------------------------------------------

규칙 60 표준예외를 사용하라.

이미 있는 예외들을 재사용하면 좋은점이 많다. 가장 중요한 장점은 배우기 쉽고 사용하기 편리한 API를 만들수 있다는 것이다.
두번째 장점은 가독성이 높다는 것이다

가장 널리 재사용되는 예외

``` 
IllegalArgumentException : null 이 아닌 인자의 값이 잘못되었을때
IllegalStateException : 객체 상태가 메서드 호출을 처리하기에 적절치 않을때 
NullPointException : null 값을 받으면 안되는 인자에 null이 전달 되었을때
IndexOutOfBoundsException : 인자로 주어진 첨자가 허용범위를 벗어났을때
ConcurrentModificationException : 병렬적 사용이 금지된 객체에 대한 병렬 접근이 탐지 되었을때
UnsupportedOperationException : 객체가 해당 메서드를 지원하지 않을때
```

마지막으로 어떤 예외를 재사용하면 좋을지 결정하는 것은 엄밀한 과학적 절차를 따르지 않는다
위의 표에 나열한 용례조차 상호 배제적이지 않다


------------------------------------------------------------------------

규칙 61 추상화수준에 맞는 예외를 던저라

상위계층에서는 하위 계층에서 발생하는 예외를 반드시 받아서 상위계층 추상화 수준에 맞는 예외로 바꿔서 던저야 한다
이 숙어를 예외 변환(exception translation)이라 부른다.

```
// 예외 변환
    try {
        // 낮은 수준의 추상화 계층 이용
        ...
    }catch(LowerLevelException e){
        throw new HigherLevelException(...);
    }
    
    public E get(int index){
        
        ListIterator<E> i = listIterator(index);
        try{
            return i.next();
        } catch(NoSuchElementException e){
            throw new IndexOutOfBoundsException("Index : " + index);
        }
    }
```


예외연결(exception chaining)은 예외 변환의 특별한 사례다
하위계층에서 발생한 예제 정보가 상위 계층 예외를 발생시킨 문제를 디버깅하는데 유용할때 사용된다

대부분의 표준 예외들은 예외 연결 지원 생성자를 구비하고 있다

아무 생각없이 아래 계층에서 생긴 예외를 밖으로 전달하기만 하는것보다야 예외 변환 기법이 낫지만
남용하면 안된다


------------------------------------------------------------------------

규칙 62 메서드에서 던져지는 모든 예외에 대해 문서를 남겨라

메서드를올바르게 사용하려면, 메서드에서 던져지는 예외에 대한 설명이 문서에 있어야 한다

점검지정 예외는 독립적으로 선언하고 해당 예외가 발생하는 상황은 Javadoc @throws 태크를
사용해서 정확하게 밝혀라

하위예외클래스를 여럿거느린 상위 예외클래스를 나열하면 안된다

모든 무점검 예외까지 선언할 필요는 없으나, 점검지정 예외들과 마찬가지로 주의해서 문서로 남겨 놓으면 좋다

Javadoc @throws 태그를 사용해서 메서드에서 발생 가능한 모든 무점검 예외에 대한 문서를 남겨라
하지만 메서드 선언부의 throws 뒤에 무점검 예외를 나열하지 마라

같은 이유로 동일한 예외를 던지는메서드가 많다면, 메서드마다 문서를 만드는 대신
해당 예외에 대한 문서는 클래스의 문서화 주석에 남겨도 된다


------------------------------------------------------------------------

규칙 63 어떤오류인지를 드러내는 정부를 상세한 메시지에 담아라

오류 정보를 포착해 내기 위해서는, 오류의 상세 메시지에 "예외에 관계된" 모든 인자와 필드의 값을 포함시켜야 한다.

예를들면, IndexOutOfBoundsException 의 예외메세지에는 첨자의 하한과 상한, 그리고 그 범위를 벗어난 첨자값이 포함되어야한다

------------------------------------------------------------------------

규칙 64 실패 원자성 달성을 위해 노력하라

메서드 호출이 정상적으로 처리되지못한 객

체의 상태는,
메서드 호출 전 상태와 동일해야 한다 .
이 속성을 만족하는 메서드는 실패 원자성을 갖추었다고 한다

실패원자성을 달성하는 방법은 여러가지가 있다
1. 가장 간단한 벙법은 변경불가는 객체로 설계하는 것이다 
2. 변경가능한 객체의 경우에는 실제 연산을 수행하기 전에 인자 유효성을 검사하는 것이 가장 보편적인 방법이다.
```
public Object pop(){
    if(size == 0)
        throw new EmptyStackException(); // 실패원자성 달성
    Object result = elements[--size];
    elements[size] = null; // 만기 참조 제거
    return result;
}

```
3. 연산 수행 도중에 발생하는 오류를 가로채는 복구 코드를 작성하는 것.
4. 마지막 접근법은, 객체의 임시 복사본상에서 필요한 연산을 수행하고 연산이 끝난 다음에 임시 복사본의 내용을 객체 상태로 바꾸는 것

실패 원자성은 일반적으로 권장되는 덕목이지만 언제나 달성할 수 있는 것은 아니다
예를 들어 같은 객체를 여러 스레드가 적절한 동기화 없이 동시에 변경할 경우 객체 상태의 일관성은 깨질 수 있따

명심할 규칙은, 메서드 명세에 포함된 예외가 발생하더라도 객체 상태는 메서드 호출 이전과 동일하게 유지 되어야 한다는 것이다
이규칙을 지키지 못할 경우 객체 상태가 어떻게 변하는지 API 문서에 명확하게 서술해야 한다

------------------------------------------------------------------------

규칙 65 예외를 무시하지 마라

API 설계자가 예외가 발생할 수 있다고 선언했다면 그것은 API를 이용할 프로그래머에게 무언가를 알리려는 것이다
무시하지 마라

```
       // catch 블록을 비워놓으면 예외는 무시된다. - 심히 의심스러운 코드 !!!
    try{
    	...
    }catch(SomrException e){
	
    }

```
빈 catch 블록은 예외를 선언한 목적, 그러니깐 예외적 상황을 반드시 처리하도록 강제한다는 목적에 배치된다
적어도 catch 블록 안에는 예외를 무시해도 괜찮은 이유라도 주석으로 남겨두어야 한다.

------------------------------------------------------------------------
