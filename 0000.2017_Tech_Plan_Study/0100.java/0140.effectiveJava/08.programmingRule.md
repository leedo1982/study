
# 08장 일반적인 프로그래밍 원칙
> 자바 언어의 기본적인 부분을 다룬다.

------------------------------------------------------------------------
## 규칙 45. 지역변수의 유효범위를 최소화하라

지역변수의 유효범위를 최소화하면 가독성과 유지보수성이 좋아지고 오류발생가능성도 줄여든다.

**지역변수의 유효범위를 최소화하는 가장 강력한 기법은, 처음으로 사용하는 곳에서 선언하는 것이다.**

**거의 모든 지역변수 선언에는 초기값이 포함되어야 한다.**

순환문(loop)를 잘 쓰면 변수의 유효범위를 최소화할 수 있다.

while 보다 범위의 제한이 있는 for문을 쓰는 것이 좋다.

while 문에서는 복사 붙여넣기 버그가 발생할수 있으나(변수선언범위때문)
for, foreach문에서는 컴파일 조차되지 않을것이다.
더욱이 for 문을 사용할때는 순환문마다 다른 이름의 변수를 이용할 필요가 없다.

**마지막전략은, 메서드의 크기를 줄이고 특정한 기능에 집중하라는 것이다.**



------------------------------------------------------------------------
## 규칙 52. 객체를 참조할 때는 그 인터페이스를 사용하라

만일 적당한 인터페이스 자료형이 있다면, 인자나 반환값, 변수, 그리고 필드의 자료형은클래스 대신 인터페이스로 선언하자.
객체의 실제 클래스를 참조할 필요가 있는 유일한 순간은, 생성자로 객체를 생성할때다.

```java
    // 인터페이스를 자료형으로 사용하고 있는 바람직한 예제
    List<Subscriber> subscribers = new Vector<Subscriber>();


    // 클래스를 자료형으로 사용하는, 나쁜예제
    Vector<Subscriber> subscribers = new Vector<Subscriber>();
```

인터페이스를 자료형으로 쓰는 습관을 들이면 프로그램은 더욱 유연해진다.

한가지 주의할 것이 있다. 만일원래 구현이 인터페이스의 일바ㄴ규약에 없는 특별한
기능을 제공하고 있었고 원래 코드가 그 기능을 사용하고 있었다면, 새로운 구현도 같은 기능을 제공해야한다.

가령 위의 예에서, Vector의 동기화 정첵을 이용하고 있었다고 하자.
그렇다면 Vector를 ArrayList로 바꿔버리면곤란할 것이다.

적당한 인터페이스가 없는 경우에는 객체를 클래스로 참조하는 것이 당연하다.

인터페이스 대신 클래스를 핵심자료형으로 사용하는 프레임워크에 속한 객체는, 구현 클래스 대신 보통abstract 로 선언되는
기반 클래스로 참조하는 것이 바람직하다.

------------------------------------------------------------------------
## 규칙 53. 리플렉션 대신 인터페이스를 이용하라

java.lang.reflect의 핵심 리플렉션 기능을 이용하면 메모리에 적재된 클래스의 정보를 가져오는 프로그램을 작성할 수 있다.
클래스의 멤버이름이나 필드 자료형, 메서드 시그니처 등의 정보를 얻어낼 수 있다.
게다가 반영적으로(reflectively) 조작할 수 있다.

또한 리플렉션을 이용하면, 소스코드가 컴파일 될 당시에는 존재하지도 않았던 클래스를 이용할 수 있다.
하지만 이런 능력에는 대가가 따른다.

1. 컴파일 시점에 자료형을 검사합으로써 얻을 수 있는 이점들을 포기해야 한다.
2. 리플렉션 기능을 이용하는 코드는 보기 싫은데다가 장황하다.
3. 성능이 낮다.

핵심 리플렉션 기능은 원래 컴포넌트 기반 응용프로그램 저작 도구를 위해 설계된 기능이었다.
일단 완성된 프로그램에서는 리플렉션을 더이상 사용하지 않는다. 리플렉션은 설계할 때만 활용된다.
> 명심할 것은, 일반적인 프로그램은 프로그램 실행 중에 리플렉션을 통해 객체를 이용하려 하면 안된다는 것이다.

리플렉션 기능으 필요한 몇가지 경우
1. 클래스 브라우저
2. 객체 검사 도구
3. 코드 분석도구
4. 해석적 내장형 시스템

> 리플렉션을 아주 제한적으로 사용하면 오버헤드는 피하면서도 리플렉션의 다양한 장점을 누릴 수 있다.

컴파일 시점에 존재하지 않는 클래스를 이용해야 하는 프로그램 상당수는, 해당 클래스 객체를 참조하는데 사용할 수 있는
인터페이스나 상위클래스를 컴파일 시점에 이미 갖추고 있는 경우가 많다.

> 그럴때, 객체 생성은 리플렉션으로 하고 객체 참조는 인터페이스나 상위클래스를 통하면 된다.

호출해야 하는 생성자가 아무런 인자도 받지 않을때는 java.lang.reflect를 이용할 필요조차 없다.
Class.newInstance 메서드를 호출하는 것으로 충분하다.

드물게 쓰이긴 하지만, 리플렉션은 실행시점에 존재하지 않는 클래스나 메서드, 필드에 대한 종속성을 관리하는데 적합하다.

요약하자면, 리플렉션은 특정한 종류의 복잡한 시스템 프로그래밍에 필요한 강력한 도구다.
하지만 단점이 많다. 컴파일 시점에는 알 수 없는 클래스를 이용하는 프로그램을 작성하고 있다면, 리플렉션을 사용하되
가능하면 객체를 만들때만 이용하고, 객체를 참조할 때는 컴파일 시에 알고 있는 인터페이스나 상위 클래스를 이용해라.


------------------------------------------------------------------------
## 규칙 54. 네이티브(native) 메서드는 신중하게 사용하라

전통적으로 네이티브 메서드는 세가지 용도로 쓰였다.
네이티브 메서드를 사용하면 레지스트리나 파일락 같은, 특정 플랫폼에 고유한 기능을 이용할 수 있다. 
또한 이미 구현되어 있는 라이브러리를 이용할 수 있으며, 그 라이브러리를 통해 기존 데이터를 활용할 수 있다.
마지막으로, 네이티브 메서드를 사용하면 성능이 중요한 부분의 처리를 네이티브 언어에 맡길 수 있다.

> 네이티브 메서드를 통해 성능을 개선하는 것을 추천하고 싶지 않다.

네이티브 메서드에는 심각한 문제가 있다. 네이티브 언어는 안전하지 않으므로, 네이티브 메서드를 이용하는 프로그램은
메모리 훼손 문제로 부터 자유로울 수 없다.
게다가 플랫폼에 종속적이므로 이식성이 낮다. 디버깅도 어렵다.
게다가 네이티브 메서드를 사용하려면 이해하기도 어렵고 작성하기도 난감한 "접착코드(glue code)"를 작성해야 한다.

------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------

