
# 06장 열거형(enum)과 어노테이션 
> 자바 1.5 에서 새로운 참조 자료형이 추가되었다. 
> 열거자료형(enum type)이라 불리는 새로운 종류의 클래스와 어노테이션 자료형이라 불리는 새로운 종류의 인터페이스가 그것이다.

------------------------------------------------------------------------
## 규칙 33. ordinal을배열 첨자로 사용하는대신 EnumMap을 이용하라

때로, ordinal 메서드가 반환하는 값을 배열 첨자로 이용하는 코드를 만날 ㅐ가 있다.

```java
    class Herb {
        enum Type {ANNUAL, PEPRNNIAL, BIENNIAL }

        final String name;
        final Type type;

        Herb(String name, Type type){
            this.name = name;
            this.type = type;
        }

        @Override
        public String toString(){
            return name;
        }
    }

    // ordnal() 값을 배열 첨자로 사용 - 이러시면 곤란합니다.
    Herb[] garden = ...;

    Set<Herb>[] herbsByType = (Set<Herb>[]) new Set[Herb.Type.values().length];

    for(int i = 0; i < herbsByType.length ; i++){
        herbsByType[i] = new HashSet<Herb>();
    }
    
    for(Herb h : garden){
        herbsByType[h.type.ordnal()].add(h);
    }

    // 결과출력
    for(int i = 0; i < herbsByType.length ; i++){
        System.out.printf("%s : %s%n", Herb.Type.values()[i], herbsByType[i]);
    }
```

동작은 하나 문제 투성이...
가장 심각한 문제는 enum의ordinal 값으로 배열 원소를 참조할 때, 정확한 int 값이 사용되도록 해야한다는 것이다.
int 는 enum과 같은 수준의 형안전성을 보장하지 않는다.

더좋은 방법은 위의 배열은 enum 상수를 어떤 값에 대응시킬 목적으로 사용되고 있는데,
    그런 용도라면 Map을 쓰면 된다.

```
    // EnumMap을 사용해 enum 상수별 데이터를 저장하는 프로그램
    Map<Herb.Type, Set<Herb>> herbsByType = new EnumMap<Herb.Type, Set<Herb>>(Herb.Type.class);

    for(Herb.Type t : Herb.Type.values()){
        herbsByType.put(t, new HashSeti<Herb>);
    }

    for(Herb h : garden){
        herbsByType.get(h.type).add(h);
    }
    System.out.println(herbsByType);
```
EnumMap 생성자는 키의 자료형을 나타내는 Class 객체를 인자로 받는다는 것에 주의하자.
이런 Class 객체를 한정적 자료형 토큰이라고 부르는데, 실행시점 제네릭 자료형 정보를 제공한다.

요약하자면 ordinal값을 배열 첨자로 사용하는 것은 적절치 않다는 것이다.
대신 EnumMap을 써라.
여러분이 표현해야하는 관계가 다차원이라면 EnumMap<...,EnumMap<...>> 같이 표현하면 된다.

------------------------------------------------------------------------

## 규칙 34. 확장 가능한 enum을 만들려 한다면 인터페이스를 이용하라 

enum 자료형이 임의의 인터페이스를 구현할 수 있다.
```
// 인터페이스를 이용해 확장 가능하게 만든 enum 자료형
public inferface Operation {
    double apply(double x, double y);
}

pulbic enum BasicOperation implement Operation {
    PLUS("+"){
        public double apply(double x, double y){ return x + y;}
    },
    MINUS("-"){
        public double apply(double x, double y){ return x - y;}
    },
    TIMES("*"){
        public double apply(double x, double y){ return x * y;}
    },
    DIVIDE("/"){
        public double apply(double x, double y){ return x / y;}
    }

    private final String symbol;

    BasicOperation(String symbol){
        this.symbol = symbol;
    }

    @Override public String toString(){
        return symbol;
    }
}

```

BasicOperation 은 enum 자료형이라 계승할 수 없지만  Operation 은 인터페이스라 확장이 가능하다.

이 인터페이스를 계승하는 새로운 enum 자료형을 만들면 Operation 객체가 필요한 곳에 
해당 enum의 자료형 상수를 이용할수 있게 된다.

예를 들어 위의 기본 연산을 확장해서 지수연산과 나머지 연산을 추가하고 싶다면


```
// 인터페이스를 이용해 기존 enum 자료형을 확장하는 사례

pulbic enum ExtendedOperation implement Operation {
    EXP("^"){
        public double apply(double x, double y){ return Math.pow(x, y);}
    },
    REMAINDER("%"){
        public double apply(double x, double y){ return x % y;}
    }

    private final String symbol;

    BasicOperation(String symbol){
        this.symbol = symbol;
    }

    @Override public String toString(){
        return symbol;
    }
}

```

새로 만든 연산들은 기존 연산들이 쓰였던 곳에는 어디든 사용할 수 있다.
API가 BasicOperation 가 아니라 Operation을 사용하도록 작성되어 있기만 하면 된다.

인터페이스를 사용해 확장 가능한 enum 자료형을 만드는 방법에는 한가지 사소한 문제가 있다.
enum 구현 자체는 계승할 수 없다는 것이다.
Operation  예제의 경우 각 연산을 나타네는 기호를 저장하고 꺼내는 코드는 중복된다.

요약하자면, 계승 가능 enum 자료형은 만들 수 없지만, 인터페이스를 만들고 그 인터페이스를 구현하는 기본 enum
자료형을 만들면 계승가능 enum 자료형을 흉내낼 수 있다.

------------------------------------------------------------------------
------------------------------------------------------------------------

