1.정의  
외부함수(포하마고 있는)의 변수에 접근할 수 있는 내부 함수.  
클로저는 독립적인(자유)변수를 가리키는 함수 이다. 또는 클로저 안에서 정의된 함수는 만들어진 환경을 기억한다.  

2.어휘의 범위
```
function init(){
  var name = "모질라";
  function displayName(){ // 내부함수, 즉 클로져인 displayName()
    alert(name);
  }
  displayName();
}
init();
```
displayName()는 함수 init()안에 정의되어 그함수 안에서만 사용할 수 있는 내부 함수이다.  
자신은 지역변수를 가지지 않지만 외부함수에 정의된 변수에 접근하는 권한이 있어 부모함수 에 있는 변수 name를 사용할 수 있다.  
이 예제는 함수스코핑(functional scoping)을 보여지기 위한 예제로,  
자바스크립트에서 중첩된 함수는 그 ㅎ마수 외부에서 정의된 변수를 사용할 수 있다.  

3.클로저
```
function makeFunc(){
  var name = '모질라';
  function displayName(){
    alert(name);
  }
  return displayName;
}

var myFunc = makeFunc();
myFunc();
```
이 코드는 init()함수와 동일한 결과를 보인다.  
위 예제와 다른점, 흥미로운점은 외부함수의 리턴값이 내부함수 displayName()라는 것이다.

이 코드가 여전히 작도하는 것은 직관적이지 않다. 일반적으로 함수 안에 정의된 지역변수는 함수가 실행하는  
동안에만 존재한다. makeFunc()함수가 종료될때 이 함수 내부에 정의된 지역변수는 없어지는게 상식적이다.  
이 코드가 문제없이 동작하는걸 보면 다른일이 일어나고 있는것 같다....  

이것은 myFunc함수가 클로저이기 때문이다. 클로저는 두개의 것(함수, 그함수가 만들어진 환경)으로 이루어진  
특별한 객체의 한 종류이다. 환경이라함은 클로저가 생성될 때 그 범위 안에 있던 여러지역 변수들로 이루어진다.
myFunc는 displayName함수와 '모질라' 문자열을 포함하는 클로저 이다.  

```
function makeAdder(x){
  return function(y){
    return x + y;
  }
}

var add5  = makeAdder(5);
var add10 = makeAdder(10);

print(add5(2)); // 7
print(add10(2)); // 12

```

add5와 add10은 둘다 클로져이다. 두함수는 같은 정의를 가지지만 다른 환경을 저장한다.  
add5의 환경에서 x는 5이지만, add10의 환경에서 x는 10이다.  

4. 실용적인 클로저
여기까지는 이론이었다. 클로저는 실용적인가?  
어떤 데이터(환경)와 함수를 연관시키는데 클로저를 사용할 수 있다. 이건 객체지향 프로그래밍과 유사하다.  
객체지향 프로그래밍에서는 객체가 데이터(그 객체의 속성)와 하나 이상의 메소드를 연관시킨다.  

결론적으로 오직 하나의 메소드를 가지고 있는 오브젝트를 사용하는 곳에 일반적으로 클로저를 사용할 수 있다.  

웹프로그래밍에서 이런 일이 많이 일어난다. 많은 자바스크립트 코드가 이벤트를 기반으로 짜여진다.  
(특정한 동작을 만들고 클릭이나 키보드 누르기에 이동장을 연결시킨다)이벤트에 반을하는 코드를 만든다고 할 수 있겠다.
이런 코드들을 콜백(callBack)라고 부른다.

여기에 실용적인 예쩨, 페이지의 클자 크기를 조정하는 몇개의 버튼을 만든다고 생각해보자.   
body엘리먼트에 px단위로 font-size를 설정하고 다른 엘리먼트에서는 상대적인 em 단위로 font-size를 설정하면 된다.
```
body{
  font-family:Helvetica,Arial,sans-serif;
  font-size:12px;
}
h1{
  font-size : 1.5em;
}
h2{
  font-size : 1.2em;
}
```
이제 body엘리먼트의 font-size만 마꾸면, font-size가 em 단위로 설정된 다른 엘리먼트들의 글자 크기도 바뀔겄이다.
```
function makeSizer(size){
  return funtion(){
    document.body.style.fontSize = size + "px";
  };
}
var size12 = makeSizer(12);
var size14 = makeSizer(14);
var size16 = makeSizer(16);
```
```
document.getElementById('size-12').onclick = size12;
document.getElementById('size-14').onclick = size14;
document.getElementById('size-16').onclick = size16;
```
```
<a href="#" id="size-12">12</a>
<a href="#" id="size-14">14</a>
<a href="#" id="size-16">16</a>
```

5. 클로저를 이용해서 private함수 흉내내기  
자바스크립트는 private 메소드를 지원하지 않지만 클로저를 이용해서 흉내낼 수 있다.  
private 함수는 코드에 제한적인 접근만을 허용한다는 점뿐만 아니라 전역 네임스페이스를 깔끔하게 유지할 수 있다는 점에서 중요하다.  
  
아래에 모듈패턴 이라고 알려진 클로저를 통해 몇개의 public함수가 private함수와 변수에 접근하는 코드가 있다.
```
var counter = (function(){
  var privateCounter = 0;
  function changeBy(val){
    privateCounter += val;
  }
  return {
    increment : function(){
      changeBy(1);
    },  
    decrement : function(){
      changeBy(-1);
    },
    value : function(){
      return privateCounter;
    }
  }
})();

console.log(counter.value()); // logs 0
counter.increment();
counter.increment();
console.log(counter.value()); // logs 2
counter.decrement();
console.log(counter.value()); // logs 1
```
이전 예제에서는 각 클로저가 자기자신만의 환경을 가졌지만, 이예제에서는 하나의 환경을  
counter.incremtne, counter.decrement, counter.value 세함수가 공유한다.

공유되는 환경은 정의되자마지 실행되는 익명함수 안에서 만들어진다.  
이 환경에는 두개의 private아이텡이 준재한다. 하나는 privateCoutner이라는 변수고,  
나머지 하나는 changBy라는 함수이다.  
이 두아이템 모두 익명함수 외부에선 접근할 수 없다. 하지만 익명함수 안에 정으된 세개의 public함수에서 사용되고 반환된다.

이 세개의 public함수는 같은 환경을 공유하는 클로저 이다. 자바스크립트 문법적 스코핑(lexical scoping) 덕분에  
세 함수 모두 privateCounter 변수와 changeBy 함수에 접근할 수 있다.

익명함수가 카운터를 정의하고 이것을 counter변수에 할당한다는 걸 알아채렸을 것이다.  
이함수를 다른 변수에 저장하고 이 변수를 이용해 여러개의 카운터를 만들수도 있다.  

```
var makeCounter = function(){
  var privateCounter = 0;
  function changeBy(val) {
    privateCounter += val;
  }
  return {
    increment: function() {
      changeBy(1);
    },
    decrement: function() {
      changeBy(-1);
    },
    value: function() {
      return privateCounter;
    }
  } 
};

var counter1 = makeCounter();
var counter2 = makeCounter();
alert(counter1.value()); // 0
counter1.increment();
counter1.increment();
alert(counter1.value()); // 2
counter1.decrement();
alert(counter1.value()); // 1
alert(counter2.value()); // 0
```
두개의 카운터가 어떻게 독립적으로 존재하는지 주목하라.  
makeCounter()함수를 호출하면서 생긴환경은 호출할때마다 다르다. 콜로져 변수 privateCounter는 다른 인스턴스를 가진다.

객체지향 프로그램잉을 사용할때 얻는 이점인 정보은닉과 캡슐화를 클로저를 사용함으로써 얻을 수 있다.

6.  자주하는 실수 : 반복문 안에서 클로저 만들기  
자바스크립트 1.7의 let키워드가 도입되기 이전에는 반복문 안에서 클로저를 생성해서 문제가 되는 경우가 빈번했다.
```
<p id="help">Helpful notes will appear here</p>
<p>E-mail: <input type="text" id="email" name="email"></p>
<p>Name: <input type="text" id="name" name="name"></p>
<p>Age: <input type="text" id="age" name="age"></p>
```
```
function showHelp(help){
  document.getElementById('help').innerHTML = help;
}

function setupHelp(){
  var helpText = [
    {'id' : 'email', 'help' : 'Your e-mail address'},
    {'id' : 'name', 'help' : 'Your full name'},
    {'id' : 'age', 'help' : 'Your age(you must be over 16)'}
  ];

  for(var i = 0; i < helpText.length; i++){
    var item = helpText[i];
    document.getElementById(item.id).onfocus = function(){
      showHelp(item.help);
    }
  }
}
setupHelp;




  


7.  성능과 관련해서






thanks for your  
출처 : https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Closures
