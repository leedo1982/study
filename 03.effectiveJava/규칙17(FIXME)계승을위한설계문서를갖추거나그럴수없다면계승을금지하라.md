## 규칙17 계승을 위한 설계와 문서를 갖추거나 그럴수 없다면 계승을금지하라

우선 메서드를 재정의하면 무슨일이 생기는지 정확하게 문서로 남겨야한다.
다시말해, **재정의 가능 메서드를 내부적으로 어떻게 사용하는지 반드시 문서에 남기라는 것이다**
public나 protected로 선언된 모든 메서드와 생성자에 대해, 어떤 재정의 가능 메서드를 어떤
순서로 호출하는지, 그리고 효출 결과가 추후 어떤 영향을 미치는지 문서로 남기라는 것이다.

**계승을 위해 설계한 클래스를 테스트할 유일한 방법은 하위클래스를 직접 만들어 보는 것이다.**
경험적으로 보자면, 계승에 맞게 클래스를 테스트하는 데는 하위클래스 세개면 대체로 충분하다.
이들 가운데 하나 이상은 상위클래스를 구현한 사람과는 다른 사람이 만들어야 한다.

계승을 허용하려면 반드시 따라야 할 제약사항이 몇가지 더 있다.
첫번째, 생성자는 직접적이건 간접적이건 재정의 가능 메서드를 호출해서는 안된다는 것이다.
마지막으로 Serializable 인터페이스를 구현하는 계승용 클래스에 readResolve 와 wirteReplace 메서드가
있다면, 두 메서드는 private 가 아니라 protected로 선언해야 한다.

이런 여러가지 제약 문제를 푸는 가장 좋은 방법은, 계승에 맞도록 설계하고 문서화하지 않은 클래스에
대한 하위 클래스는 만들지 않는 것이다.
하위 클래스 생성을 금지하는 방법은 두가지가 있다.  
가장 쉬운 방법은 클래스를 final로 선언하는 것이다. 그 대안은 모든 생성자를 private 나 package-private
로 선언하고 생성자 대신 public 정적 팩터리 메서드를 추가하는 것이다 
