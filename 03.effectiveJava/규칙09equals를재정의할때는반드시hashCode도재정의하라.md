
## 규칙09 equals를 재정의 할때는 반드시 hashCode도 재정의 하라.

많은버그가 hashCode를 재정의 하지 않아서 발생한다.  
**equals 메서드를 재정의하는 클래스는 반드시 hashCode 메서드도 재정의 해야한다.**
그렇지 않으면 Object.hashCode 의 일반규약을 어기게 되므로, hash기반 컬렉션과 함께 사용시 오작동한다.

Object 클래스 명세에 복사해온 일반 규약
- 같은 객체의 hashCode 를 여러번 호출하는 경우, equals 가 사용하는 정보들이 변경되지 않았다면, 
언제나 동일한 정수가 반환되어야 한다.
- equals(Object) 메서드가 같다고 판정한 두객체의 hashCode 값은 같아야한다.
- equals(Object) 메서드가 다르다고 판정한 두객체의 hashCode 값은 꼭 다를 필요는 없다.

**hashCode 를 재정의하지 않으면 두번째 규약이 위반된다.**

```java
	// hashCode 재정의 없이 PhoneNumber 생성
	Map<PhoneNumber, String> m = new Map<PhoneNumber, String>();
	m.put(new PhoneNumber(707, 867, 5309), "Jenny");

	m.get(new PhoneNumber(707, 867, 5309));
	// 결과는?! null 이 나옴...두 개의 PhoneNumber 객체가 사용되없음에 유의

```

하나는 HashMap 에 삽입할 때 사용한 객체이고, 
다른 하나는  HashMap 에서 꺼낼때 사용한 객체이다.
PhoneNumber 에서 hashCode 를 재정의 하지 않았으므로 두 객체는 서로 다른 해시코드를 같는다.

HashMap 은 성능 최적화를 위해 내부에 보관된 항목의 해시코드를 캐시해 두고, 캐시괸 해시코드가 없는
객체는 동일성 검사 하지 않는다.

이문제를 수정하는 간단한 방법은 적절한 hashCode 메서드를 구현하는 것이다.

```java
	// 가장 끔직한 형태의 해시함수. 절대로 이렇게 구현하지 말것
	@Override public int hashCode() { return 42;}
```

위의 메서드가 문제 없다고 한것은, 같은 객체는 같은 해시코드를 갖기 때문이다.  
그러나 모든 객체가 같은 해시 코드를 가지게 되니 끔직하다......
전부 같은 버킷에 해시되므로 해시 테이블은 결국 연결 리스트가 되어 버린다.

이상적인 해시 함수에  '가까운'함수를 만드는 건 별로 어렵지않다. 

중복필드는 해시코드계산 과정에서 제외해도 된다. 다시말해 다른 필드에서 유도 될 수 있는 값을 갖는
필드는 무시해도 된다. equals 계산에 쓰이지 않는 필드는 반드시 제외해야 하는데, 그렇지 않으면 
hashCode의 두번째 일반 규약을 깨뜨리게 되기 때문이다. 

**주의할 것은, 성능을 개선하려고 객체의 중요부분을 해시코드 계산 과정에서 생략하면 안 된다는 것이다.**



